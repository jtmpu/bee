module Main where

import Options.Applicative
import Data.Semigroup ((<>))

import Control.Monad.Reader

import qualified Bee.Environment as E
import qualified Bee.Engine.Storage as S

newtype Arguments = Arguments {
    optCommand :: Command
}

data Command = List Bool (Maybe String) | Cat

main :: IO ()
main = do
    args <- execParser optsParser
    executeCommand (optCommand args)
    where
        optsParser :: ParserInfo Arguments
        optsParser =
            info
                (helper <*> versionOption <*> programOptions)
                (fullDesc <> progDesc "Bee hive introspection" <>
                header
                    "List executed commands and retrieve data generated by them.")
        versionOption :: Parser (a -> a)
        versionOption = infoOption "0.1" (long "version" <> help "Show version")
        programOptions :: Parser Arguments
        programOptions =
            Arguments <$> hsubparser (listCommand <> catCommand)
        listCommand :: Mod CommandFields Command
        listCommand = 
            command
                "list"
                (info listOptions (progDesc "List executed commands"))
        listOptions :: Parser Command
        listOptions =
            List <$> switch (short 'a' <> long "all" <> help "List all commands") 
                 <*> optional (strOption (short 'p' <> long "program" <> help "List all executions for a program"))
        catCommand :: Mod CommandFields Command
        catCommand =
            command
                "cat"
                (info (pure Cat) (progDesc "Get information from a command execution"))

executeCommand :: Command -> IO ()
executeCommand Cat = putStrLn "data"
executeCommand (List False (Just program)) = putStrLn program
executeCommand (List False Nothing) = putStrLn ""
executeCommand (List True _) = do
    env <- E.mkDefaultBeeEnvironment
    keys <- S.getStorageKeys env
    putStrLn "done"
